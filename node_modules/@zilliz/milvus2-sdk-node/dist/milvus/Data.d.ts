import { Client } from "./Client";
import { Collection } from "./Collection";
import { CalcDistanceReq, DeleteEntitiesReq, FlushReq, GetFlushStateReq, GetQuerySegmentInfoReq, InsertReq, LoadBalanceReq } from "./types/Data";
import { CalcDistanceResponse, FlushResult, GetFlushStateResponse, GetMetricsResponse, GetQuerySegmentInfoResponse, MutationResult, QueryResults, ResStatus, SearchResults } from "./types/Response";
import { GetMetricsRequest, QueryReq, SearchReq } from "./types/Search";
export declare class Data extends Client {
    vectorTypes: number[];
    collectionManager: Collection;
    constructor(client: any, collectionManager: Collection);
    /**
     * Insert data into Milvus.
     *
     * @param data
     *  | Property                | Type                   |           Description              |
     *  | :---------------------- | :--------------------  | :-------------------------------  |
     *  | collection_name         | String                 |       Collection name       |
     *  | partition_name(optional)| String                 |       Partition name       |
     *  | fields_data             | { [x: string]: any }[] |      If the field type is binary, the vector data length needs to be dimension / 8   |
     *  | hash_keys(optional)    | Number[]               |  The hash value depends on the primarykey value       |
     *
     * @return
     *  | Property    |           Description              |
     *  | :-------------| :-------------------------------  |
     *  | status        |  { error_code: number, reason: string }|
     *  | succ_index    |  Index array of the successfully inserted data      |
     *  | err_index    |   Index array of the unsuccessfully inserted data      |
     *  | IDs    |        ID array of the successfully inserted data      |
     *
     *
     * #### Example
     *
     * ```
     *  new milvusClient(MILUVS_ADDRESS).dataManager.insert({
     *    collection_name: COLLECTION_NAME,
     *    fields_data: [{
     *      vector_field: [1,2,2,4],
     *      scalar_field: 1
     *    }]
     *  });
     * ```
     */
    insert(data: InsertReq): Promise<MutationResult>;
    /**
     * Delete entities in Milvus
     *
     * @param data
     *  | Property                | Type                   |           Description              |
     *  | :---------------------- | :--------------------  | :-------------------------------  |
     *  | collection_name         | String                 |       Collection name       |
     *  | partition_name(optional)| String                 |       Partition name       |
     *  | expr    | String        |  Boolean expression used to filter attribute.    |
     *
     * @return
     *  | Property    |           Description              |
     *  | :-------------| :-------------------------------  |
     *  | status        |  { error_code: number, reason: string }|
     *  | IDs    |        ID array of the successfully deleted data      |
     *
     *
     * #### Example
     *
     * ```
     *  new milvusClient(MILUVS_ADDRESS).dataManager.deleteEntities({
     *    collection_name: COLLECTION_NAME,
     *    expr: 'id in [1,2,3,4]'
     *  });
     * ```
     */
    deleteEntities(data: DeleteEntitiesReq): Promise<MutationResult>;
    /**
     * Perform vector similarity search.
     *
     * @param data
     *  | Property                | Type                   |           Description              |
     *  | :---------------------- | :--------------------  | :-------------------------------  |
     *  | collection_name         | String                 |        Collection name       |
     *  | partition_names(optional)| String[]              |        Array of partition names       |
     *  | expr(optional)           | String                |      Scalar field filter expression    |
     *  | search_params            | Object        |    anns_field: vector field name <br/> topk: search result counts <br/> [metric_type](https://milvus.io/docs/v2.0.0/metric.md#floating#Similarity-Metrics) <br/>params: search params   |
     *  | vectors                  | Number[][]            |  Original vector to search with  |
     *  | output_fields(optional)  | String[]              |  Support scalar field  |
     *  | vector_type              | enum                  |  Binary field -> 100, Float field -> 101  |
     *  | travel_timestamp          | number                  |  We can get timestamp after insert success. Use this timestamp we can time travel in vector search.|
  
     * @return
     *  | Property    |           Description              |
     *  | :-------------| :-------------------------------  |
     *  | status        |  { error_code: number, reason: string }|
     *  | results    |        {score:number,id:string}[];       |
     *
     *
     *
     * #### Example
     *
     * ```
     *  new milvusClient(MILUVS_ADDRESS).dataManager.search({
     *   collection_name: COLLECTION_NAME,
     *   expr: "",
     *   vectors: [[1, 2, 3, 4]],
     *   search_params: {
     *     anns_field: VECTOR_FIELD_NAME,
     *     topk: "4",
     *     metric_type: "L2",
     *     params: JSON.stringify({ nprobe: 1024 }),
     *   },
     *   output_fields: ["age", "time"],
     *   vector_type: 100,
     *  });
     * ```
     */
    search(data: SearchReq): Promise<SearchResults>;
    /**
     * Milvus temporarily buffers the newly inserted vectors in the cache. Call `flush()` to persist them to the object storage.
     * It's async function, so it's will take some times to excute.
     * @param data
     *  | Property                | Type   |           Description              |
     *  | :---------------------- | :----  | :-------------------------------  |
     *  | collection_names        | String[] |        Array of collection names      |
     *
     * @return
     *  | Property    |           Description              |
     *  | :-------------| :-------------------------------  |
     *  | status        |  { error_code: number, reason: string }|
     *
     * #### Example
     *
     * ```
     *  new milvusClient(MILUVS_ADDRESS).dataManager.flush({
     *     collection_names: ['my_collection'],
     *  });
     * ```
     */
    flush(data: FlushReq): Promise<FlushResult>;
    /**
     * It's same function as flush. But flushSync is sync function.
     * So you can ensure it's flushed after function return the result.
     *
     * @param data
     *  | Property                | Type   |           Description              |
     *  | :---------------------- | :----  | :-------------------------------  |
     *  | collection_names        | String[] |        Array of collection names      |
     *
     * @return
     *  | Property    |           Description              |
     *  | :-------------| :-------------------------------  |
     *  | status        |  { error_code: number, reason: string }|
     *
     * #### Example
     *
     * ```
     *  new milvusClient(MILUVS_ADDRESS).dataManager.flushSync({
     *     collection_names: ['my_collection'],
     *  });
     * ```
     */
    flushSync(data: FlushReq): Promise<GetFlushStateResponse>;
    /**
     * Query vector data in Milvus. Current release of Milvus only supports expression as fieldname in [id1,id2,id3]
     *
     * @param data
     *  | Property                     | Type   |           Description              |
     *  | :--------------------------- | :----  | :-------------------------------  |
     *  | collection_name              | String |        Collection name      |
     *  | expr                         | String |       Scalar field filter expression     |
     *  | partitions_names(optional)   | String[] |       Array of partition names      |
     *  | output_fields                | String[] |       Vector or scalar field to be returned    |
     *
     *
     *
     * @return
     *  | Property    |           Description              |
     *  | :-------------| :-------------------------------  |
     *  | status        |  { error_code: number,reason:string } |
     *  | data   |  Data of all fields that you defined in `output_fields`, {field_name: value}[] |
     *
     *
     * #### Example
     *
     * ```
     *  new milvusClient(MILUVS_ADDRESS).dataManager.query({
     *    collection_name: 'my_collection',
     *    expr: "age in [1,2,3,4,5,6,7,8]",
     *    output_fields: ["age"],
     *  });
     * ```
     */
    query(data: QueryReq): Promise<QueryResults>;
    /**
     * @ignore
     * @param data
     *  | Property             | Type   |           Description                      |
     *  | :------------------- | :----  | :----------------------------------------  |
     *  | request              | object |        Only allow "system_info" for now    |
     */
    getMetric(data: GetMetricsRequest): Promise<GetMetricsResponse>;
    /**
     * @ignore
     * @param data
     */
    calcDistance(data: CalcDistanceReq): Promise<CalcDistanceResponse>;
    /**
     * Get flush state by segment ids
     *
     * @param data
     *  | Property                | Type   |           Description              |
     *  | :---------------------- | :----  | :-------------------------------  |
     *  | segmentIDs              | Array  |       The segment ids        |
     *
     *
     *
     * @return
     *  | Property    |           Description              |
     *  | :-----------| :-------------------------------  |
     *  | status      |  { error_code: number,reason:string } |
     *  | flushed     |  segments flushed or not  |
     *
     *
     * #### Example
     *
     * ```
     *   const res = await milvusClient.dataManager.getFlushState({
     *    segmentIDs: segIds,
     *   });
     * ```
     */
    getFlushState(data: GetFlushStateReq): Promise<GetFlushStateResponse>;
    /**
     * Do load balancing operation from source query node to destination query node.
     * Only work in cluster milvus.
     *
     * @param data
     *  | Property            | Type     |           Description              |
     *  | :-------------------| :----    | :-------------------------------  |
     *  | src_nodeID          | number   |     The source query node id to balance.        |
     *  | dst_nodeIDs         | number[] |     The destination query node ids to balance.(optional)        |
     *  | sealed_segmentIDs   | number[] |     Sealed segment ids to balance.(optional)       |
     *
     *
     * @return
     *  | Property    |           Description              |
     *  | :-----------| :-------------------------------  |
     *  | status      |  { error_code: number,reason:string } |
     *  | infos       |  segments infomations  |
     *
     *
     * #### Example
     *
     * ```
     *   const res = await dataManager.loadBalance({
     *      src_nodeID: 31,
     *   });
     * ```
     */
    loadBalance(data: LoadBalanceReq): Promise<ResStatus>;
    /**
     * Notifies Proxy to return segments information from query nodes.
     *
     * @param data
     *  | Property                | Type   |           Description              |
     *  | :---------------------- | :----  | :-------------------------------  |
     *  | collectionName          | String |      The name of the collection to get segments info.       |
     *
     *
     *
     * @return
     *  | Property    |           Description              |
     *  | :-----------| :-------------------------------  |
     *  | status      |  { error_code: number,reason:string } |
     *  | infos       |  QuerySegmentInfo is the growing segments's information in query cluster.  |
     *
     *
     * #### Example
     *
     * ```
     *   const res = await dataManager.getQuerySegmentInfo({
     *      collectionName: COLLECTION,
     *    });
     * ```
     */
    getQuerySegmentInfo(data: GetQuerySegmentInfoReq): Promise<GetQuerySegmentInfoResponse>;
}
