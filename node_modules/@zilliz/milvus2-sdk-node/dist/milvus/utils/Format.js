"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.datetimeToHybrids = exports.unixtimeToHybridts = exports.hybridtsToUnixtime = exports.formatNumberPrecision = exports.parseToKeyValue = exports.formatKeyValueData = void 0;
var index_1 = require("./index");
var ErrorReason_1 = require("../const/ErrorReason");
/**
 *  parse [{key:"row_count",value:4}] to {row_count:4}
 * @param data key value pair array
 * @param keys all keys in data
 * @returns {key:value}
 */
var formatKeyValueData = function (data, keys) {
    var result = {};
    keys.forEach(function (k) {
        var value = index_1.findKeyValue(data, k);
        result[k] = value;
    });
    return result;
};
exports.formatKeyValueData = formatKeyValueData;
/**
 * parse {row_count:4} to [{key:"row_count",value:"4"}]
 * @param data Object
 * @return {KeyValuePair[]}
 */
var parseToKeyValue = function (data) {
    return data
        ? Object.keys(data).reduce(function (pre, cur) { return __spreadArray(__spreadArray([], pre), [{ key: cur, value: data[cur] }]); }, [])
        : [];
};
exports.parseToKeyValue = parseToKeyValue;
/**
 *
 * @param number Number like 3.1738998889923096
 * @param precision The precision you want, if is 3 will return 3.173 and If is 2 will return 3.17
 * @returns
 */
var formatNumberPrecision = function (number, precision) {
    return Number(number
        .toString()
        .split(".")
        .map(function (v, i) {
        if (i === 1) {
            return v.slice(0, precision);
        }
        return v;
    })
        .join("."));
};
exports.formatNumberPrecision = formatNumberPrecision;
var LOGICAL_BITS = BigInt(18);
// const LOGICAL_BITS_MASK = (1 << LOGICAL_BITS) - 1;
var checkTimeParam = function (ts) {
    switch (typeof ts) {
        case "bigint":
            return true;
        case "string":
            return isNaN(Number(ts)) ? false : true;
        default:
            return false;
    }
};
/**
 * Convert a hybrid timestamp to UNIX Epoch time ignoring the logic part.
 *
 * @param data
 *  | Property          | Type   |           Description              |
 *  | :---------------- | :----  | :-------------------------------  |
 *  | hybridts          | String or BigInt |    The known hybrid timestamp to convert to UNIX Epoch time. Non-negative interger range from 0 to 18446744073709551615.       |
 *
 *
 *
 * @return
 *  | Property    |           Description              |
 *  | :-----------| :-------------------------------  |
 *  | unixtime as string      |  The Unix Epoch time is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT). |
 *
 *
 * #### Example
 *
 * ```
 *   const res = hybridtsToUnixtime("429642767925248000");
 * ```
 */
var hybridtsToUnixtime = function (hybridts) {
    if (!checkTimeParam(hybridts)) {
        throw new Error("hybridts " + ErrorReason_1.ERROR_REASONS.TIMESTAMP_PARAM_CHECK);
    }
    var timestamp = typeof hybridts === "bigint" ? hybridts : BigInt(hybridts);
    var physical = timestamp >> LOGICAL_BITS;
    return (physical / BigInt(1000)).toString();
};
exports.hybridtsToUnixtime = hybridtsToUnixtime;
/**
 * Generate a hybrid timestamp based on Unix Epoch time, timedelta and incremental time internval.
 *
 * @param data
 *  | Property          | Type   |           Description              |
 *  | :---------------- | :----  | :-------------------------------  |
 *  | unixtime          | string or bigint |    The known Unix Epoch time used to generate a hybrid timestamp.  The Unix Epoch time is the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT).       |
 *
 *
 *
 * @return
 *  | Property    | Type   |           Description              |
 *  | :-----------| :---   | :-------------------------------  |
 *  | Hybrid timetamp       | String   | Hybrid timetamp is a non-negative interger range from 0 to 18446744073709551615. |
 *
 *
 * #### Example
 *
 * ```
 *   const res = unixtimeToHybridts("429642767925248000");
 * ```
 */
var unixtimeToHybridts = function (unixtime) {
    if (!checkTimeParam(unixtime)) {
        throw new Error("hybridts " + ErrorReason_1.ERROR_REASONS.TIMESTAMP_PARAM_CHECK);
    }
    var timestamp = typeof unixtime === "bigint" ? unixtime : BigInt(unixtime);
    var physical = (timestamp * BigInt(1000)) << LOGICAL_BITS;
    return physical.toString();
};
exports.unixtimeToHybridts = unixtimeToHybridts;
/**
 * Generate a hybrid timestamp based on datetimeã€‚
 *
 * @param data
 *  | Property          | Type   |           Description              |
 *  | :---------------- | :----  | :-------------------------------  |
 *  | datetime          | Date |    The known datetime used to generate a hybrid timestamp.       |
 *
 *
 *
 * @return
 *  | Property    | Type   |           Description              |
 *  | :-----------| :---   | :-------------------------------  |
 *  | Hybrid timetamp       | String   | Hybrid timetamp is a non-negative interger range from 0 to 18446744073709551615. |
 *
 *
 * #### Example
 *
 * ```
 *   const res = datetimeToHybrids("429642767925248000");
 * ```
 */
var datetimeToHybrids = function (datetime) {
    if (!(datetime instanceof Date)) {
        throw new Error("hybridts " + ErrorReason_1.ERROR_REASONS.DATE_TYPE_CHECK);
    }
    return exports.unixtimeToHybridts((datetime.getTime() / 1000).toString());
};
exports.datetimeToHybrids = datetimeToHybrids;
//# sourceMappingURL=Format.js.map