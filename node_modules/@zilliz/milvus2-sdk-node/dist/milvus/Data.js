"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Data = void 0;
var protobufjs_1 = __importDefault(require("protobufjs"));
var utils_1 = require("../utils");
var Client_1 = require("./Client");
var ErrorReason_1 = require("./const/ErrorReason");
var Common_1 = require("./types/Common");
var Response_1 = require("./types/Response");
var index_1 = require("./utils/index");
var Blob_1 = require("./utils/Blob");
var path_1 = __importDefault(require("path"));
var Format_1 = require("./utils/Format");
var protoPath = path_1.default.resolve(__dirname, "../grpc-proto/milvus.proto");
var Data = /** @class */ (function (_super) {
    __extends(Data, _super);
    function Data(client, collectionManager) {
        var _this = _super.call(this, client) || this;
        _this.vectorTypes = [Common_1.DataType.BinaryVector, Common_1.DataType.FloatVector];
        _this.collectionManager = collectionManager;
        return _this;
    }
    /**
     * Insert data into Milvus.
     *
     * @param data
     *  | Property                | Type                   |           Description              |
     *  | :---------------------- | :--------------------  | :-------------------------------  |
     *  | collection_name         | String                 |       Collection name       |
     *  | partition_name(optional)| String                 |       Partition name       |
     *  | fields_data             | { [x: string]: any }[] |      If the field type is binary, the vector data length needs to be dimension / 8   |
     *  | hash_keys(optional)    | Number[]               |  The hash value depends on the primarykey value       |
     *
     * @return
     *  | Property    |           Description              |
     *  | :-------------| :-------------------------------  |
     *  | status        |  { error_code: number, reason: string }|
     *  | succ_index    |  Index array of the successfully inserted data      |
     *  | err_index    |   Index array of the unsuccessfully inserted data      |
     *  | IDs    |        ID array of the successfully inserted data      |
     *
     *
     * #### Example
     *
     * ```
     *  new milvusClient(MILUVS_ADDRESS).dataManager.insert({
     *    collection_name: COLLECTION_NAME,
     *    fields_data: [{
     *      vector_field: [1,2,2,4],
     *      scalar_field: 1
     *    }]
     *  });
     * ```
     */
    Data.prototype.insert = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var collection_name, collectionInfo, fieldsData, params, promise;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.checkCollectionName(data);
                        if (!data.fields_data ||
                            !Array.isArray(data.fields_data) ||
                            !data.fields_data.length) {
                            throw new Error(ErrorReason_1.ERROR_REASONS.INSERT_CHECK_FILEDS_DATA_IS_REQUIRED);
                        }
                        collection_name = data.collection_name;
                        return [4 /*yield*/, this.collectionManager.describeCollection({
                                collection_name: collection_name,
                            })];
                    case 1:
                        collectionInfo = _a.sent();
                        if (collectionInfo.status.error_code !== Response_1.ErrorCode.SUCCESS) {
                            throw new Error(collectionInfo.status.reason);
                        }
                        fieldsData = collectionInfo.schema.fields
                            .filter(function (v) { return !v.is_primary_key || !v.autoID; })
                            .map(function (v) { return ({
                            name: v.name,
                            type: v.data_type,
                            dim: Number(index_1.findKeyValue(v.type_params, "dim")),
                            value: [],
                        }); });
                        params = __assign(__assign({}, data), { num_rows: data.fields_data.length });
                        // You need to parse the original row data to column data for Milvus.
                        data.fields_data.forEach(function (v, i) {
                            // Set the key as the field name to get all names in a row.
                            var fieldNames = Object.keys(v);
                            fieldNames.forEach(function (name) {
                                var target = fieldsData.find(function (item) { return item.name === name; });
                                if (!target) {
                                    throw new Error(ErrorReason_1.ERROR_REASONS.INSERT_CHECK_WRONG_FIELD + " " + i);
                                }
                                var isVector = _this.vectorTypes.includes(Common_1.DataTypeMap[target.type.toLowerCase()]);
                                // Check if the dimension is matched when the data type is BinaryVector.
                                if (Common_1.DataTypeMap[target.type.toLowerCase()] === Common_1.DataType.BinaryVector &&
                                    v[name].length !== target.dim / 8) {
                                    throw new Error(ErrorReason_1.ERROR_REASONS.INSERT_CHECK_WRONG_DIM);
                                }
                                // Value in vector field should be array. Therefore you need concat it.
                                // but array.concat is slow, we need for loop to push the value one by one
                                if (isVector) {
                                    for (var _i = 0, _a = v[name]; _i < _a.length; _i++) {
                                        var val = _a[_i];
                                        target.value.push(val);
                                    }
                                }
                                else {
                                    target.value[i] = v[name];
                                }
                            });
                        });
                        params.fields_data = fieldsData.map(function (v) {
                            var _a, _b, _c, _d;
                            // milvus return string for field type, so we define the DataTypeMap to the value we need.
                            // but if milvus change the string, may casue we cant find value.
                            var type = Common_1.DataTypeMap[v.type.toLowerCase()];
                            var key = _this.vectorTypes.includes(type) ? "vectors" : "scalars";
                            var dataKey = "float_vector";
                            switch (type) {
                                case Common_1.DataType.FloatVector:
                                    dataKey = "float_vector";
                                    break;
                                case Common_1.DataType.BinaryVector:
                                    dataKey = "binary_vector";
                                    break;
                                case Common_1.DataType.Double:
                                    dataKey = "double_data";
                                    break;
                                case Common_1.DataType.Float:
                                    dataKey = "float_data";
                                    break;
                                case Common_1.DataType.Int64:
                                    dataKey = "long_data";
                                    break;
                                case Common_1.DataType.Int32:
                                case Common_1.DataType.Int16:
                                case Common_1.DataType.Int8:
                                    dataKey = "int_data";
                                    break;
                                case Common_1.DataType.Bool:
                                    dataKey = "bool_data";
                                    break;
                                default:
                                    throw new Error(ErrorReason_1.ERROR_REASONS.INSERT_CHECK_WRONG_DATA_TYPE);
                            }
                            return _a = {
                                    type: type,
                                    field_name: v.name
                                },
                                _a[key] = type === Common_1.DataType.FloatVector
                                    ? (_b = {
                                            dim: v.dim
                                        },
                                        _b[dataKey] = {
                                            data: v.value,
                                        },
                                        _b) : type === Common_1.DataType.BinaryVector
                                    ? (_c = {
                                            dim: v.dim
                                        },
                                        _c[dataKey] = Blob_1.parseBinaryVectorToBytes(v.value),
                                        _c) : (_d = {},
                                    _d[dataKey] = {
                                        data: v.value,
                                    },
                                    _d),
                                _a;
                        });
                        return [4 /*yield*/, utils_1.promisify(this.client, "Insert", params)];
                    case 2:
                        promise = _a.sent();
                        return [2 /*return*/, promise];
                }
            });
        });
    };
    /**
     * Delete entities in Milvus
     *
     * @param data
     *  | Property                | Type                   |           Description              |
     *  | :---------------------- | :--------------------  | :-------------------------------  |
     *  | collection_name         | String                 |       Collection name       |
     *  | partition_name(optional)| String                 |       Partition name       |
     *  | expr    | String        |  Boolean expression used to filter attribute.    |
     *
     * @return
     *  | Property    |           Description              |
     *  | :-------------| :-------------------------------  |
     *  | status        |  { error_code: number, reason: string }|
     *  | IDs    |        ID array of the successfully deleted data      |
     *
     *
     * #### Example
     *
     * ```
     *  new milvusClient(MILUVS_ADDRESS).dataManager.deleteEntities({
     *    collection_name: COLLECTION_NAME,
     *    expr: 'id in [1,2,3,4]'
     *  });
     * ```
     */
    Data.prototype.deleteEntities = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var promise;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!data || !data.collection_name || !data.expr) {
                            throw new Error(ErrorReason_1.ERROR_REASONS.DELETE_PARAMS_CHECK);
                        }
                        return [4 /*yield*/, utils_1.promisify(this.client, "Delete", data)];
                    case 1:
                        promise = _a.sent();
                        return [2 /*return*/, promise];
                }
            });
        });
    };
    /**
     * Perform vector similarity search.
     *
     * @param data
     *  | Property                | Type                   |           Description              |
     *  | :---------------------- | :--------------------  | :-------------------------------  |
     *  | collection_name         | String                 |        Collection name       |
     *  | partition_names(optional)| String[]              |        Array of partition names       |
     *  | expr(optional)           | String                |      Scalar field filter expression    |
     *  | search_params            | Object        |    anns_field: vector field name <br/> topk: search result counts <br/> [metric_type](https://milvus.io/docs/v2.0.0/metric.md#floating#Similarity-Metrics) <br/>params: search params   |
     *  | vectors                  | Number[][]            |  Original vector to search with  |
     *  | output_fields(optional)  | String[]              |  Support scalar field  |
     *  | vector_type              | enum                  |  Binary field -> 100, Float field -> 101  |
     *  | travel_timestamp          | number                  |  We can get timestamp after insert success. Use this timestamp we can time travel in vector search.|
  
     * @return
     *  | Property    |           Description              |
     *  | :-------------| :-------------------------------  |
     *  | status        |  { error_code: number, reason: string }|
     *  | results    |        {score:number,id:string}[];       |
     *
     *
     *
     * #### Example
     *
     * ```
     *  new milvusClient(MILUVS_ADDRESS).dataManager.search({
     *   collection_name: COLLECTION_NAME,
     *   expr: "",
     *   vectors: [[1, 2, 3, 4]],
     *   search_params: {
     *     anns_field: VECTOR_FIELD_NAME,
     *     topk: "4",
     *     metric_type: "L2",
     *     params: JSON.stringify({ nprobe: 1024 }),
     *   },
     *   output_fields: ["age", "time"],
     *   vector_type: 100,
     *  });
     * ```
     */
    Data.prototype.search = function (data) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var root, collectionInfo, targetField, dim, vectorType, dimension, PlaceholderGroup, placeholderGroupParams, placeholderGroupBytes, promise, results, round_decimal, _b, topks, scores_1, fields_data, ids, fieldsData_1, idData_1;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, protobufjs_1.default.load(protoPath)];
                    case 1:
                        root = _c.sent();
                        this.checkCollectionName(data);
                        if (!data.search_params ||
                            !data.search_params.anns_field ||
                            !data.search_params.metric_type ||
                            !data.search_params.topk ||
                            !data.search_params.params) {
                            throw new Error(ErrorReason_1.ERROR_REASONS.SEARCH_PARAMS_IS_REQUIRED);
                        }
                        if (!this.vectorTypes.includes(data.vector_type))
                            throw new Error(ErrorReason_1.ERROR_REASONS.SEARCH_MISS_VECTOR_TYPE);
                        return [4 /*yield*/, this.collectionManager.describeCollection({
                                collection_name: data.collection_name,
                            })];
                    case 2:
                        collectionInfo = _c.sent();
                        targetField = collectionInfo.schema.fields.find(function (v) { return v.name === data.search_params.anns_field; });
                        if (!targetField) {
                            throw new Error(ErrorReason_1.ERROR_REASONS.SEARCH_NOT_FIND_VECTOR_FIELD);
                        }
                        dim = index_1.findKeyValue(targetField.type_params, "dim");
                        vectorType = Common_1.DataTypeMap[targetField.data_type.toLowerCase()];
                        dimension = vectorType === Common_1.DataType.BinaryVector ? Number(dim) / 8 : Number(dim);
                        if (!data.vectors[0] || data.vectors[0].length !== dimension) {
                            throw new Error(ErrorReason_1.ERROR_REASONS.SEARCH_DIM_NOT_MATCH);
                        }
                        PlaceholderGroup = root.lookupType("milvus.proto.milvus.PlaceholderGroup");
                        placeholderGroupParams = PlaceholderGroup.create({
                            placeholders: [
                                {
                                    tag: "$0",
                                    type: data.vector_type,
                                    values: data.vectors.map(function (v) {
                                        return data.vector_type === Common_1.DataType.BinaryVector
                                            ? Blob_1.parseBinaryVectorToBytes(v)
                                            : Blob_1.parseFloatVectorToBytes(v);
                                    }),
                                },
                            ],
                        });
                        placeholderGroupBytes = PlaceholderGroup.encode(placeholderGroupParams).finish();
                        return [4 /*yield*/, utils_1.promisify(this.client, "Search", __assign(__assign({}, data), { dsl: data.expr || "", dsl_type: Common_1.DslType.BoolExprV1, placeholder_group: placeholderGroupBytes, search_params: Format_1.parseToKeyValue(data.search_params) }))];
                    case 3:
                        promise = _c.sent();
                        results = [];
                        round_decimal = data.search_params.round_decimal;
                        if (promise.results) {
                            _b = promise.results, topks = _b.topks, scores_1 = _b.scores, fields_data = _b.fields_data, ids = _b.ids;
                            fieldsData_1 = fields_data.map(function (item, i) {
                                // if search result is empty, will cause value is undefined.
                                var value = item.field ? item[item.field] : undefined;
                                return {
                                    type: item.type,
                                    field_name: item.field_name,
                                    data: value ? value[value === null || value === void 0 ? void 0 : value.data].data : "",
                                };
                            });
                            idData_1 = ids ? (_a = ids[ids.id_field]) === null || _a === void 0 ? void 0 : _a.data : undefined;
                            /**
                             *  milvus support mutilple querys to search
                             *  milvus will return all columns data
                             *  so we need to format value to row data for easy to use
                             *  topk is the key we can splice data for every search result
                             */
                            topks.forEach(function (v, index) {
                                var topk = Number(v);
                                scores_1.splice(0, topk).forEach(function (score, scoreIndex) {
                                    var i = index === 0 ? scoreIndex : scoreIndex + topk;
                                    var fixedScore = typeof round_decimal === "undefined" || round_decimal === -1
                                        ? score
                                        : Format_1.formatNumberPrecision(score, round_decimal);
                                    var result = {
                                        score: fixedScore,
                                        id: idData_1 ? idData_1[i] : "",
                                    };
                                    fieldsData_1.forEach(function (field) {
                                        result[field.field_name] = field.data[i];
                                    });
                                    results.push(result);
                                });
                            });
                        }
                        return [2 /*return*/, {
                                status: promise.status,
                                results: results,
                            }];
                }
            });
        });
    };
    /**
     * Milvus temporarily buffers the newly inserted vectors in the cache. Call `flush()` to persist them to the object storage.
     * It's async function, so it's will take some times to excute.
     * @param data
     *  | Property                | Type   |           Description              |
     *  | :---------------------- | :----  | :-------------------------------  |
     *  | collection_names        | String[] |        Array of collection names      |
     *
     * @return
     *  | Property    |           Description              |
     *  | :-------------| :-------------------------------  |
     *  | status        |  { error_code: number, reason: string }|
     *
     * #### Example
     *
     * ```
     *  new milvusClient(MILUVS_ADDRESS).dataManager.flush({
     *     collection_names: ['my_collection'],
     *  });
     * ```
     */
    Data.prototype.flush = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!data ||
                            !Array.isArray(data.collection_names) ||
                            !data.collection_names.length) {
                            throw new Error(ErrorReason_1.ERROR_REASONS.COLLECTION_NAME_IS_REQUIRED);
                        }
                        return [4 /*yield*/, utils_1.promisify(this.client, "Flush", data)];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, res];
                }
            });
        });
    };
    /**
     * It's same function as flush. But flushSync is sync function.
     * So you can ensure it's flushed after function return the result.
     *
     * @param data
     *  | Property                | Type   |           Description              |
     *  | :---------------------- | :----  | :-------------------------------  |
     *  | collection_names        | String[] |        Array of collection names      |
     *
     * @return
     *  | Property    |           Description              |
     *  | :-------------| :-------------------------------  |
     *  | status        |  { error_code: number, reason: string }|
     *
     * #### Example
     *
     * ```
     *  new milvusClient(MILUVS_ADDRESS).dataManager.flushSync({
     *     collection_names: ['my_collection'],
     *  });
     * ```
     */
    Data.prototype.flushSync = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var res, segIDs, isFlushed, flushRes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!data ||
                            !Array.isArray(data.collection_names) ||
                            !data.collection_names.length) {
                            throw new Error(ErrorReason_1.ERROR_REASONS.COLLECTION_NAME_IS_REQUIRED);
                        }
                        return [4 /*yield*/, utils_1.promisify(this.client, "Flush", data)];
                    case 1:
                        res = _a.sent();
                        segIDs = Object.keys(res.coll_segIDs)
                            .map(function (v) { return res.coll_segIDs[v].data; })
                            .reduce(function (pre, cur) { return __spreadArray(__spreadArray([], pre), cur); }, []);
                        isFlushed = false;
                        flushRes = null;
                        _a.label = 2;
                    case 2:
                        if (!!isFlushed) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.getFlushState({ segmentIDs: segIDs })];
                    case 3:
                        flushRes = _a.sent();
                        return [4 /*yield*/, index_1.sleep(100)];
                    case 4:
                        _a.sent();
                        isFlushed = flushRes.flushed;
                        return [3 /*break*/, 2];
                    case 5: 
                    // Before Milvus pre-GA will throw error
                    return [2 /*return*/, flushRes];
                }
            });
        });
    };
    /**
     * Query vector data in Milvus. Current release of Milvus only supports expression as fieldname in [id1,id2,id3]
     *
     * @param data
     *  | Property                     | Type   |           Description              |
     *  | :--------------------------- | :----  | :-------------------------------  |
     *  | collection_name              | String |        Collection name      |
     *  | expr                         | String |       Scalar field filter expression     |
     *  | partitions_names(optional)   | String[] |       Array of partition names      |
     *  | output_fields                | String[] |       Vector or scalar field to be returned    |
     *
     *
     *
     * @return
     *  | Property    |           Description              |
     *  | :-------------| :-------------------------------  |
     *  | status        |  { error_code: number,reason:string } |
     *  | data   |  Data of all fields that you defined in `output_fields`, {field_name: value}[] |
     *
     *
     * #### Example
     *
     * ```
     *  new milvusClient(MILUVS_ADDRESS).dataManager.query({
     *    collection_name: 'my_collection',
     *    expr: "age in [1,2,3,4,5,6,7,8]",
     *    output_fields: ["age"],
     *  });
     * ```
     */
    Data.prototype.query = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var promise, results, fieldsData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.checkCollectionName(data);
                        return [4 /*yield*/, utils_1.promisify(this.client, "Query", data)];
                    case 1:
                        promise = _a.sent();
                        results = [];
                        fieldsData = promise.fields_data.map(function (item, i) {
                            var _a;
                            if (item.field === "vectors") {
                                var key_1 = item.vectors.data;
                                var vectorValue = key_1 === "float_vector"
                                    ? item.vectors[key_1].data
                                    : item.vectors[key_1].toJSON().data;
                                // if binary vector , need use dim / 8 to split vector data
                                var dim_1 = ((_a = item.vectors) === null || _a === void 0 ? void 0 : _a.data) === "float_vector"
                                    ? Number(item.vectors.dim)
                                    : Number(item.vectors.dim) / 8;
                                var data_1 = [];
                                // parse number[] to number[][] by dim
                                vectorValue.forEach(function (v, i) {
                                    var index = Math.floor(i / dim_1);
                                    if (!data_1[index]) {
                                        data_1[index] = [];
                                    }
                                    data_1[index].push(v);
                                });
                                return {
                                    field_name: item.field_name,
                                    data: data_1,
                                };
                            }
                            var key = item.scalars.data;
                            var scalarValue = item.scalars[key].data;
                            return {
                                field_name: item.field_name,
                                data: scalarValue,
                            };
                        });
                        // parse column data to [{fieldname:value}]
                        fieldsData.forEach(function (v) {
                            v.data.forEach(function (d, i) {
                                var _a, _b;
                                if (!results[i]) {
                                    results[i] = (_a = {},
                                        _a[v.field_name] = d,
                                        _a);
                                }
                                else {
                                    results[i] = __assign(__assign({}, results[i]), (_b = {}, _b[v.field_name] = d, _b));
                                }
                            });
                        });
                        return [2 /*return*/, {
                                status: promise.status,
                                data: results,
                            }];
                }
            });
        });
    };
    /**
     * @ignore
     * @param data
     *  | Property             | Type   |           Description                      |
     *  | :------------------- | :----  | :----------------------------------------  |
     *  | request              | object |        Only allow "system_info" for now    |
     */
    Data.prototype.getMetric = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!data || !data.request || !data.request.metric_type) {
                            throw new Error(ErrorReason_1.ERROR_REASONS.GET_METRIC_CHECK_PARAMS);
                        }
                        return [4 /*yield*/, utils_1.promisify(this.client, "GetMetrics", {
                                request: JSON.stringify(data.request),
                            })];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, __assign(__assign({}, res), { response: JSON.parse(res.response) })];
                }
            });
        });
    };
    /**
     * @ignore
     * @param data
     */
    Data.prototype.calcDistance = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, utils_1.promisify(this.client, "CalcDistance", data)];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, res];
                }
            });
        });
    };
    /**
     * Get flush state by segment ids
     *
     * @param data
     *  | Property                | Type   |           Description              |
     *  | :---------------------- | :----  | :-------------------------------  |
     *  | segmentIDs              | Array  |       The segment ids        |
     *
     *
     *
     * @return
     *  | Property    |           Description              |
     *  | :-----------| :-------------------------------  |
     *  | status      |  { error_code: number,reason:string } |
     *  | flushed     |  segments flushed or not  |
     *
     *
     * #### Example
     *
     * ```
     *   const res = await milvusClient.dataManager.getFlushState({
     *    segmentIDs: segIds,
     *   });
     * ```
     */
    Data.prototype.getFlushState = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!data || !data.segmentIDs) {
                            throw new Error(ErrorReason_1.ERROR_REASONS.GET_FLUSH_STATE_CHECK_PARAMS);
                        }
                        return [4 /*yield*/, utils_1.promisify(this.client, "GetFlushState", data)];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, res];
                }
            });
        });
    };
    /**
     * Do load balancing operation from source query node to destination query node.
     * Only work in cluster milvus.
     *
     * @param data
     *  | Property            | Type     |           Description              |
     *  | :-------------------| :----    | :-------------------------------  |
     *  | src_nodeID          | number   |     The source query node id to balance.        |
     *  | dst_nodeIDs         | number[] |     The destination query node ids to balance.(optional)        |
     *  | sealed_segmentIDs   | number[] |     Sealed segment ids to balance.(optional)       |
     *
     *
     * @return
     *  | Property    |           Description              |
     *  | :-----------| :-------------------------------  |
     *  | status      |  { error_code: number,reason:string } |
     *  | infos       |  segments infomations  |
     *
     *
     * #### Example
     *
     * ```
     *   const res = await dataManager.loadBalance({
     *      src_nodeID: 31,
     *   });
     * ```
     */
    Data.prototype.loadBalance = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!data || !data.src_nodeID) {
                            throw new Error(ErrorReason_1.ERROR_REASONS.LOAD_BALANCE_CHECK_PARAMS);
                        }
                        return [4 /*yield*/, utils_1.promisify(this.client, "LoadBalance", data)];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, res];
                }
            });
        });
    };
    /**
     * Notifies Proxy to return segments information from query nodes.
     *
     * @param data
     *  | Property                | Type   |           Description              |
     *  | :---------------------- | :----  | :-------------------------------  |
     *  | collectionName          | String |      The name of the collection to get segments info.       |
     *
     *
     *
     * @return
     *  | Property    |           Description              |
     *  | :-----------| :-------------------------------  |
     *  | status      |  { error_code: number,reason:string } |
     *  | infos       |  QuerySegmentInfo is the growing segments's information in query cluster.  |
     *
     *
     * #### Example
     *
     * ```
     *   const res = await dataManager.getQuerySegmentInfo({
     *      collectionName: COLLECTION,
     *    });
     * ```
     */
    Data.prototype.getQuerySegmentInfo = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!data || !data.collectionName) {
                            throw new Error(ErrorReason_1.ERROR_REASONS.COLLECTION_NAME_IS_REQUIRED);
                        }
                        return [4 /*yield*/, utils_1.promisify(this.client, "GetQuerySegmentInfo", data)];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, res];
                }
            });
        });
    };
    return Data;
}(Client_1.Client));
exports.Data = Data;
//# sourceMappingURL=Data.js.map